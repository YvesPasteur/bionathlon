!function(t){function i(i){for(var o,r,h=i[0],a=i[1],l=i[2],d=0,w=[];d<h.length;d++)r=h[d],Object.prototype.hasOwnProperty.call(n,r)&&n[r]&&w.push(n[r][0]),n[r]=0;for(o in a)Object.prototype.hasOwnProperty.call(a,o)&&(t[o]=a[o]);for(c&&c(i);w.length;)w.shift()();return s.push.apply(s,l||[]),e()}function e(){for(var t,i=0;i<s.length;i++){for(var e=s[i],o=!0,h=1;h<e.length;h++){var a=e[h];0!==n[a]&&(o=!1)}o&&(s.splice(i--,1),t=r(r.s=e[0]))}return t}var o={},n={0:0},s=[];function r(i){if(o[i])return o[i].exports;var e=o[i]={i:i,l:!1,exports:{}};return t[i].call(e.exports,e,e.exports,r),e.l=!0,e.exports}r.m=t,r.c=o,r.d=function(t,i,e){r.o(t,i)||Object.defineProperty(t,i,{enumerable:!0,get:e})},r.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},r.t=function(t,i){if(1&i&&(t=r(t)),8&i)return t;if(4&i&&"object"==typeof t&&t&&t.__esModule)return t;var e=Object.create(null);if(r.r(e),Object.defineProperty(e,"default",{enumerable:!0,value:t}),2&i&&"string"!=typeof t)for(var o in t)r.d(e,o,function(i){return t[i]}.bind(null,o));return e},r.n=function(t){var i=t&&t.__esModule?function(){return t.default}:function(){return t};return r.d(i,"a",i),i},r.o=function(t,i){return Object.prototype.hasOwnProperty.call(t,i)},r.p="/";var h=window.webpackJsonp=window.webpackJsonp||[],a=h.push.bind(h);h.push=i,h=h.slice();for(var l=0;l<h.length;l++)i(h[l]);var c=a;s.push([3,1]),e()}({3:function(t,i,e){"use strict";e.r(i);var o=e(1),n=e(0);const s=new n.A;s.lineTo(-1,0),s.lineTo(-1,50),s.lineTo(-5,50),s.lineTo(0,60),s.lineTo(5,50),s.lineTo(1,50),s.lineTo(1,0),s.closePath();const r=new n.B(s);r.rotateY(Math.PI);const h=new n.G;document.addEventListener("mousemove",t=>{t.preventDefault(),h.x=t.clientX/window.innerWidth*2-1,h.y=-t.clientY/window.innerHeight*2+1});var a=class{constructor(t){this.verticalAngle=0,this.horizontalAngle=0,this.power=0,this.material=new n.p({color:"#ffffff"}),this.mesh=new n.o(r,this.material),this.mesh.rotation.x=Math.PI/2,this.mesh.position.copy(t),this.horizontalAngleObject=new n.s,this.horizontalAngleObject.add(this.mesh)}addToScene(t){t.add(this.horizontalAngleObject)}getHorizontalAngle(){return this.horizontalAngle}getVerticalAngle(){return this.verticalAngle}getPower(){return this.power}update(t){this.mesh.visible="Player camera"===t.name,this.horizontalAngle=n.n.degToRad(-45*h.x),this.verticalAngle=(h.y+1)*-Math.PI/8+Math.PI/2,this.horizontalAngleObject.rotation.y=this.horizontalAngle,this.mesh.rotation.x=this.verticalAngle}powerUp(){this.power+=.02,this.horizontalAngleObject.scale.z=this.power+1,this.material.color.setRGB(this.power<=.5?2*this.power:1,this.power>.5?2-2*this.power:1,0),this.power>1&&(this.power=0)}reset(){this.horizontalAngleObject.scale.z=1,this.material.color.setRGB(1,1,1),this.power=0}};var l=class{constructor(t){this.height=126,this.depth=30,this.restitution=.3,this.distanceFromPlayer=t.distanceFromPlayer-this.depth,this.wallBody=new n.v(new n.H(0,0,-1),this.distanceFromPlayer),this.baseBody=new n.v(new n.H(0,-1,0),this.height);const i=new n.c(t.width,this.height,this.depth);this.material=new n.q({color:"#dddddd"}),this.mesh=new n.o(i,this.material),this.mesh.position.z=t.distanceFromPlayer-this.depth/2,this.mesh.position.y=this.height/2}addToScene(t){t.add(this.mesh)}getCollisionWallBody(){return this.wallBody}getCollisionBaseBody(){return this.baseBody}};const c=[new n.G(0,0),new n.G(2.3,0),new n.G(2.6,.3),new n.G(2.6,8),new n.G(2,12),new n.G(1.2,14.2),new n.G(1.2,17.9),new n.G(1.4,17.9),new n.G(1.4,18.2),new n.G(.9,18.2)],d=new n.k(c);d.translate(0,-9.1,0);const w=new n.d(2.6,2.6,18.2,20),p=new n.p({color:"#FFFFFF",transparent:!0,opacity:.7,side:n.b}),u=new n.p({color:"#FFFFFF",transparent:!0,opacity:.7,side:n.i});var P=class{constructor(t){this.height=18.2,this.maxRadius=2.6,this.position=t;const i=new n.o(d,p),e=new n.o(d,u);this.object=new n.s,this.object.add(i),this.object.add(e),this.object.position.set(t.x,this.height/2+t.y,t.z),this.helper=new n.o(w,u),this.helper.position.set(t.x,this.height/2+t.y,t.z)}addToScene(t){t.add(this.object)}getRadius(t){return t<=8?2.6:t>8&&t<=12?2.3:t>12&&t<=14.2?1.6:t<=18.2?1.2:0}},m=e(2);var g=class{constructor(t){this.currentCamera=0,this.initPlayerCamera(t),this.initBottlesCamera(t),this.infoElement=document.querySelector("#cameraName"),this.updateCameraInfo(),document.addEventListener("keyup",t=>{"Space"===t.code&&this.toggleCamera()})}initPlayerCamera(t){this.playerCamera=new n.u(45,t.clientWidth/t.clientHeight,.1,1e3),this.playerCamera.position.set(0,170,-20),this.playerCamera.lookAt(0,100,250),this.playerCamera.zoom=30,this.playerCamera.name="Player camera"}initBottlesCamera(t){this.bottlesCamera=new n.u(45,t.clientWidth/t.clientHeight,.1,1e3),this.bottlesCamera.position.set(0,220,200),this.bottlesCamera.lookAt(0,136,280),this.bottlesCamera.zoom=30,this.bottlesCamera.name="Bottles camera";const i=new m.a(this.bottlesCamera,t);i.target.set(0,120,270),i.maxPolarAngle=Math.PI/2.1,i.update()}updateAspect(t){this.playerCamera.aspect=t.clientWidth/t.clientHeight,this.playerCamera.updateProjectionMatrix(),this.bottlesCamera.aspect=t.clientWidth/t.clientHeight,this.bottlesCamera.updateProjectionMatrix()}updateCameraInfo(){this.infoElement.innerHTML=this.getCurrentCamera().name}toggleCamera(){this.currentCamera+=1,this.currentCamera%=2,this.updateCameraInfo()}getCurrentCamera(){switch(this.currentCamera){case 0:return this.playerCamera;case 1:return this.bottlesCamera}}};var b=class{constructor(t){this.widthX=500,this.widthZ=600,this.body=new n.v(new n.H(0,-1,0),0);const i=new n.w(this.widthX,this.widthZ);i.rotateX(-Math.PI/2);const e=t.load("./checker.png");e.wrapS=n.y,e.wrapT=n.y,e.magFilter=n.r,e.repeat.set(5,5),this.material=new n.p({map:e}),this.mesh=new n.o(i,this.material)}addToScene(t){t.add(this.mesh)}getCollisionBody(){return this.body}};class y{constructor(t,i=10){const e=new n.a(i);e.material.depthTest=!1,e.renderOrder=2,t.add(e);const o=new n.j(i,i);o.material.depthTest=!1,o.renderOrder=1,t.add(o),this.grid=o,this.axes=e,this.visible=!1,this.name=t.name}get visible(){return this._visible}set visible(t){this._visible=t,this.grid.visible=t,this.axes.visible=t}get nodeName(){return this.name}}const C=new n.A;C.absellipse(0,0,5,5,0,2*Math.PI,!1,0);const f=new n.t;f.absellipse(0,0,4.2,4.2,0,2*Math.PI,!1,0),C.holes=[f];const v=new n.h(C,{depth:.3,bevelEnabled:!1});v.rotateX(-Math.PI/2);const z=new n.A;z.absellipse(0,5,.8,.8,0,2*Math.PI,!1,0);const x=new n.h(z,{depth:.3,bevelEnabled:!1});x.rotateX(-Math.PI/2);const j=new n.C(1);var A=class{constructor(t){this.radius=5,this.innerRadius=4.2,this.initialPosition=new n.H(0,0,0),this.verticalAngle=0,this.horizontalAngle=0,this.power=0,this.rotationSpeed=0,this.state="IDLE",this.previousTime=0,this.helpers=[],this.name=t,this.material=new n.p({color:"#DA6345"}),this.mesh=new n.o(v,this.material),this.mesh.geometry.computeBoundingBox(),this.mesh.name="rondelle";const i=new n.o(x,this.material);this.mesh.add(i),this.throwObject=new n.s,this.throwObject.add(this.mesh),this.throwObject.name="throwObject";new n.o(new n.C(this.radius,20,20),new n.p({color:"#FFFF00",transparent:!0,opacity:.5}));this.throwHorizontalAngleObject=new n.s,this.throwHorizontalAngleObject.add(this.throwObject),this.throwHorizontalAngleObject.name="throwHorizontalAngleObject",this.throwContainer=new n.s,this.throwContainer.add(this.throwHorizontalAngleObject),this.throwContainer.name="throwContainer",this.throwContainer.visible=!1,this.throwStartTime=0,this.wallPoint=this.initCollisionPoint("wallPoint","#00FF00"),this.wallPoint.point.position.z=this.radius,this.bottlePoint=this.initCollisionPoint("bottlePoint","#00FF00"),this.bottlePoint.point.position.z=this.radius,this.bottlePoint2=this.initCollisionPoint("bottlePoint2","#0000FF"),this.bottlePoint2.point.position.z=this.radius,this.centerPoint=this.initCollisionPoint("centerPoint","#FF0000"),this.behindPoint=this.initCollisionPoint("behindPoint","#00FF00"),this.behindPoint.point.position.z=-this.innerRadius,this.helpers.push(new y(this.throwContainer,30),new y(this.throwHorizontalAngleObject,30),new y(this.throwObject,30),new y(this.mesh,30))}initCollisionPoint(t,i,e=!1){const o={currentPosition:new n.H,previousPosition:new n.H,trajectory:new n.l,point:new n.o(j,new n.p({color:i})),container:new n.s};return o.point.name=t,o.container.add(o.point),o.container.name=t+"Container",o.container.visible=e,this.throwObject.add(o.container),o}addToScene(t){t.add(this.throwContainer),this.helpers.forEach(i=>t.add(i))}update(t,i=!1,e=!1){if("IDLE"===this.state&&!e)return;this.wallPoint.point.getWorldPosition(this.wallPoint.previousPosition),this.bottlePoint.point.getWorldPosition(this.bottlePoint.previousPosition),this.centerPoint.point.getWorldPosition(this.centerPoint.previousPosition),this.behindPoint.point.getWorldPosition(this.behindPoint.previousPosition);const o=(t-this.throwStartTime)*(i?.5:5)*.001,n=Math.cos(this.verticalAngle)*this.power*o,s=-4.905*o*o+Math.sin(this.verticalAngle)*this.power*o,r=-9.81*n/(this.power*this.power*Math.cos(this.verticalAngle)*Math.cos(this.verticalAngle))+Math.tan(this.verticalAngle),h=Math.atan(r);this.throwObject.position.set(0,s,n),this.throwObject.rotation.x=-h,this.mesh.rotation.y=t*-this.rotationSpeed*.001,this.throwContainer.updateMatrixWorld(),this.wallPoint.point.getWorldPosition(this.wallPoint.currentPosition),this.wallPoint.trajectory.set(this.wallPoint.previousPosition,this.wallPoint.currentPosition),this.bottlePoint.point.getWorldPosition(this.bottlePoint.currentPosition),this.bottlePoint.trajectory.set(this.bottlePoint.previousPosition,this.bottlePoint.currentPosition),this.centerPoint.point.getWorldPosition(this.centerPoint.currentPosition),this.centerPoint.trajectory.set(this.centerPoint.previousPosition,this.centerPoint.currentPosition),this.behindPoint.point.getWorldPosition(this.behindPoint.currentPosition),this.behindPoint.trajectory.set(this.behindPoint.previousPosition,this.behindPoint.currentPosition)}addGUI(t){const i=t.addFolder(this.name);i.open=!0,this.helpers.forEach(t=>{i.add(t,"visible").name(t.nodeName)})}startThrow(t,i,e,o,n){this.throwStartTime=t,this.initialPosition=i,this.verticalAngle=e,this.horizontalAngle=o,this.power=n,this.rotationSpeed=10,this.state="THROWING",this.throwContainer.visible=!0,this.throwContainer.position.copy(i),this.throwHorizontalAngleObject.rotation.y=this.horizontalAngle,this.throwObject.position.set(0,0,0),this.throwObject.rotation.x=0,o>=-Math.PI/2&&o<=Math.PI/2?this.wallPoint.container.rotation.y=-o:this.wallPoint.container.rotation.y=-o-Math.PI}interceptPlane(t,i,e,o){const s=new n.H;return!(!t.intersectLine(i.trajectory,s)||!e(s))&&(this.computeOffset(i.currentPosition,s),o(s),!0)}doRebound(t,i,e){i.z-=this.radius,this.startThrow(t,i,-this.throwObject.rotation.x,Math.PI-this.horizontalAngle,this.power*e)}testGroundCollision(t,i){return this.wallPoint.currentPosition.y<i.mesh.position.y&&this.interceptPlane(i.getCollisionBody(),this.wallPoint,()=>!0,t=>{this.state="IDLE",this.throwContainer.position.copy(t),this.throwObject.position.set(0,0,0),this.throwObject.rotation.x=0})}testWindowWallCollision(t,i){return this.wallPoint.currentPosition.z>=i.distanceFromPlayer&&this.interceptPlane(i.getCollisionBody(),this.wallPoint,()=>!0,e=>this.doRebound(t,e,i.restitution))}testBaseWallCollision(t,i){return!!(this.wallPoint.currentPosition.z>=i.distanceFromPlayer&&this.interceptPlane(i.getCollisionWallBody(),this.wallPoint,t=>t.y<=i.height,e=>this.doRebound(t,e,i.restitution)))||this.wallPoint.currentPosition.z>=i.distanceFromPlayer&&this.wallPoint.currentPosition.y<=i.height&&this.interceptPlane(i.getCollisionBaseBody(),this.wallPoint,()=>!0,t=>{this.state="IDLE",this.throwContainer.position.copy(t),this.throwObject.position.set(0,0,0),this.throwObject.rotation.x=0;const e=i.distanceFromPlayer+i.depth-this.radius;this.throwContainer.position.z>=e&&(this.throwContainer.position.z=e)})}testBottleCollision(t,i){const e=this.previousTime;this.previousTime=t;let o=0;const s=()=>{if(this.bottlePoint.currentPosition.y>=i.position.y&&this.bottlePoint.currentPosition.y<i.position.y+i.height){const t=new n.G(this.centerPoint.currentPosition.x,this.centerPoint.currentPosition.z),e=new n.G(i.position.x,i.position.z);if(t.distanceTo(e)<=this.radius+i.maxRadius){const s=new n.G(this.bottlePoint.currentPosition.x-t.x,this.bottlePoint.currentPosition.z-t.y),r=new n.G(e.x-t.x,e.y-t.y);o=Math.acos(s.dot(r)/(s.length()*r.length())),o=t.x<e.x?o:-o,this.bottlePoint2.container.rotation.y=o,this.bottlePoint2.container.updateMatrixWorld(),this.bottlePoint2.point.getWorldPosition(this.bottlePoint2.currentPosition);const h=new n.G(this.bottlePoint2.currentPosition.x,this.bottlePoint2.currentPosition.z).distanceTo(e),a=this.bottlePoint2.currentPosition.y-i.position.y;if(h<=i.getRadius(a))return!0}}return!1};if(s()){console.log("first collision",t),this.state="IDLE";const r=(t-e)/100;let h=!1,a=e;for(;!h&&a<=t;)this.update(a,!1,!0),h=s(),a+=r;if(h){console.log("precise collision",a);const e=new n.G(i.position.x,i.position.z),s=new n.G(this.bottlePoint2.currentPosition.x,this.bottlePoint2.currentPosition.z),r=new n.G(e.x-s.x,e.y-s.y),h=o-r.angle()-Math.PI/2;return this.startThrow(t,this.centerPoint.currentPosition,-this.throwObject.rotation.x,h,.3*this.power),!0}}return this.update(e,!1,!0),this.update(t,!1,!0),!1}testBottleIn(t,i){if(this.centerPoint.currentPosition.y>=i.position.y&&this.centerPoint.currentPosition.y<=i.position.y+i.height){const e=this.innerRadius-i.getRadius(i.height),o=new n.G(this.centerPoint.currentPosition.x,this.centerPoint.currentPosition.z),s=new n.G(i.position.x,i.position.z);if(o.distanceTo(s)<=e){const e=new n.G(this.behindPoint.currentPosition.x,this.behindPoint.currentPosition.z);let o=e.distanceTo(s),r=o+1,h=t+1;for(;o>i.getRadius(i.height)&&o<r;)this.update(h,!1,!0),h+=1,e.x=this.behindPoint.currentPosition.x,e.y=this.behindPoint.currentPosition.z,r=o,o=e.distanceTo(s);this.behindPoint.currentPosition.y<=i.position.y+i.height&&(this.update(t,!1,!0),this.state="IDLE")}}}displayPosition(t){console.log("Local position",t.name,t.position.toArray());const i=new n.H;t.getWorldPosition(i),console.log("World position",t.name,i.toArray())}computeOffset(t,i){const e=t.clone().sub(i);this.throwContainer.position.x-=e.x,this.throwContainer.position.y-=e.y,this.throwContainer.position.z-=e.z}};var T=class{constructor(){this.width=500,this.height=300,this.distanceFromPlayer=300,this.restitution=.3,this.body=new n.v(new n.H(0,0,-1),this.distanceFromPlayer);const t=new n.w(this.width,this.height);t.rotateX(-Math.PI);const i=new n.w(5,this.height);i.rotateX(-Math.PI),i.translate(0,0,-1),this.material=new n.p({color:"#87CEFA"}),this.mesh=new n.o(t,this.material);const e=new n.p({color:"#aaa"});{const t=new n.o(i,e);t.position.x=-225,this.mesh.add(t)}{const t=new n.o(i,e);t.position.x=-75,this.mesh.add(t)}{const t=new n.o(i,e);t.position.x=75,this.mesh.add(t)}{const t=new n.o(i,e);t.position.x=225,this.mesh.add(t)}this.mesh.position.z=this.distanceFromPlayer,this.mesh.position.y=this.height/2}addToScene(t){t.add(this.mesh)}getCollisionBody(){return this.body}};new o.a;const F=new n.I,O=F.domElement;F.setSize(window.innerWidth,window.innerHeight,!1),document.body.appendChild(F.domElement);const M=new n.F,H=new n.z,I=new g(O);let S=0;const W=!1,B=document.querySelector("#remainingThrows");B.innerHTML=(33-S).toString();const G=new n.G;document.addEventListener("mousemove",t=>{t.preventDefault(),G.x=t.clientX/window.innerWidth*2-1,G.y=-t.clientY/window.innerHeight*2+1});let E=!1,R=!1;document.onmousedown=function(){E=!0},document.onmouseup=function(){E=!1,R=!0};{const t=new n.e(16777215,1);t.position.set(0,300,0),t.target.position.set(0,100,250),H.add(t),H.add(t.target);const i=new n.f(t);t.target.updateMatrixWorld(),i.update()}const L=new b(M);L.addToScene(H);const D=new T;D.addToScene(H);const X=new l(D);X.addToScene(H);const k=new P(new n.H(-12,X.height,X.distanceFromPlayer+15));k.addToScene(H);const _=new P(new n.H(0,X.height,X.distanceFromPlayer+8));_.addToScene(H);const q=new P(new n.H(12,X.height,X.distanceFromPlayer+15));q.addToScene(H);const N=new a(new n.H(0,120,0));N.addToScene(H);const U=Array(33).fill(null).map((t,i)=>{const e=new A(`Rondelle ${i}`);return e.addToScene(H),e});requestAnimationFrame((function t(i){(function(t){const i=t.clientWidth,e=t.clientHeight;return t.width!==i||t.height!==e})(O)&&(F.setSize(O.clientWidth,O.clientHeight,!1),I.updateAspect(O)),N.update(I.getCurrentCamera()),U.forEach(t=>{if(t.update(i,W),"IDLE"!==t.state){let e=!1;!e&&(e=t.testGroundCollision(i,L)),!e&&(e=t.testWindowWallCollision(i,D)),!e&&(e=t.testBaseWallCollision(i,X)),!e&&(e=t.testBottleCollision(i,_)),!e&&(e=t.testBottleCollision(i,k)),!e&&(e=t.testBottleCollision(i,q))}}),I.playerCamera.lookAt(0-20*G.x,100+20*G.y,250),E&&S<33&&N.powerUp(),R&&S<33&&(R=!1,U[S].startThrow(i,new n.H(0,120,0),-N.getVerticalAngle()+Math.PI/2,N.getHorizontalAngle(),60+20*N.getPower()),S+=1,B.innerHTML=(33-S).toString(),N.reset()),F.render(H,I.getCurrentCamera()),requestAnimationFrame(t)}))}});